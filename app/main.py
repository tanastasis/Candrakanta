import jsonfrom pathlib import Pathfrom typing import Any, Dict, List, Optionalimport refrom fastapi import FastAPI, Request, Query, APIRouter, HTTPException, Body, Form as fofrom fastapi.responses import HTMLResponsefrom fastapi.templating import Jinja2Templatesfrom fastapi import HTTPExceptionfrom fastapi.responses import HTMLResponsefrom .engine.paradigm_builder import (export_paradigm_verb,                                      export_paradigm_nominal, export_paradigm_p3,                                      sublexeme, lx, dictionary_form, am, Postfixeme,Grammeme,                                      phonol, buildForm, form_to_json, Form, show_form, rules)from urllib.parse import unquote_plusimport sys, pathlibsys.path.append(str(pathlib.Path(__file__).resolve().parents[1]))BASE_DIR = Path(__file__).resolve().parent.parentDATA_FILE = BASE_DIR / "data" / "lexemes.json"app = FastAPI()templates = Jinja2Templates(directory=str(Path(__file__).resolve().parent / "templates"))_LEXEMES: Dict[str, Dict[str, Any]] = {}_VARIANTS: dict[str, dict] = {}def load_lexemes() -> Dict[str, Dict[str, Any]]:    with open(DATA_FILE, "r", encoding="utf-8") as f:        data = json.load(f)    norm: Dict[str, Dict[str, Any]] = {}    for key, row in data.items():        norm[key] = {            "name": row.get("name") or key,            "dictform": row.get("DictionaryForm" or ""),            "meaning": row.get("Meaning") or "",            "category": row.get("Category") or "",            "gender": row.get("Gender") or "",        }    return norm@app.on_event("startup")def _startup():    global _LEXEMES    _LEXEMES = load_lexemes()@app.get("/", response_class=HTMLResponse)def home(request: Request, q: str | None = None):    """    Показываем таблицу лексем. Поддерживаем простой поиск по name/meaning (q).    """    rows: List[Dict[str, Any]] = list(_LEXEMES.values())    if q:        ql = q.lower()        rows = [            r for r in rows            if ql in (r["name"] or "").lower() or ql in (r["meaning"] or "").lower() or  ql in (r["dictform"] or "").lower()        ]    rows.sort(key=lambda r: (r["name"] or "").lower())    return templates.TemplateResponse(        "home.html",        {            "request": request,            "lexemes": rows,            "q": q or "",        },    )@app.get("/lexeme/{lexeme_id}")def lexeme_page(request: Request, lexeme_id: str):    base_lex = lx.get(lexeme_id)    if not base_lex:        raise HTTPException(404, "Lexeme not found")    raw = request.query_params.get("sub", "") or ""    raw = unquote_plus(raw).strip().replace("+", ".").replace(" ", ".")    mors = [p for p in raw.split(".") if p]    cur = base_lex    if mors:        try:            cur = sublexeme(cur, mors, am=am)        except KeyError:            raise HTTPException(404, "Lexeme not found")    cat = (getattr(cur, "Category", "") or "").lower()    if cat == "verb":        payload = export_paradigm_verb(cur)        tpl = "lexeme_verb.html"    elif cur.name == "P_3":        payload = export_paradigm_p3(cur)        tpl = "lexeme_nominal.html"    else:        payload = export_paradigm_nominal(cur)        tpl = "lexeme_nominal.html"    for d in payload.get("_derivations", []):        _VARIANTS[d["variant_id"]] = d    return templates.TemplateResponse(        tpl,        {            "request": request,            "payload": payload,            "root_lexeme_id": lexeme_id,            "current_sub_chain": ".".join(mors),        },    )@app.get("/api/variant/{variant_id}/derivation", response_class=HTMLResponse)def variant_derivation_partial(request: Request, variant_id: str):    data = _VARIANTS.get(variant_id)    if not data:        raise HTTPException(status_code=404, detail="Variant not found")    # enrich steps with rule wording    steps = data.get("steps", [])    for s in steps:        rid = str(s.get("rule_id", ""))        s["wording"] = getattr(rules.get(rid, None), "wording", "") if rid in rules else ""    data["steps"] = steps  # update in place    return templates.TemplateResponse(        "partials/derivation_table.html",        {"request": request, "d": data},    )@app.post("/api/variant/{variant_id}/with_postfix", response_class=HTMLResponse)def variant_with_postfix(    request: Request,    variant_id: str,    post: str = fo(None),    show_all: str = fo("0"),):    base = _VARIANTS.get(variant_id)    if not base:        raise HTTPException(404, "Variant not found")    lexeme_id = base.get("lexeme_id")    gr_obj    = base.get("gr_obj")    if not lexeme_id or gr_obj is None:        raise HTTPException(400, "Variant lacks lexeme/grammeme context")    if "+" in lexeme_id:        mors = lexeme_id.split("+")        root = mors[0]        try:            lex = sublexeme(lx.get(root), mors[1:], am=am)        except Exception:            raise HTTPException(404, "Sublexeme not found")    else:        lex = lx.get(lexeme_id)    if not lex:        raise HTTPException(404, "Lexeme not found")    cat = (getattr(lex, "Category", "") or "").lower()    if cat == "verb":        allowed_posts = ["", "EMPH+NOM", "1+SG+OBL", "2+SG+OBL", "3+SG+OBL", "1+PL+OBL", "2+PL+OBL", "3+PL+OBL"]    else:        allowed_posts = ["", "EMPH+NOM"]    if post is not None and post not in allowed_posts:        raise HTTPException(400, f"Postfix '{post}' is not allowed for category '{cat}'")    post_list = []    if post:        for tok in (post.split("+") if post else []):            if tok:                if tok not in am:                    raise HTTPException(422, f"Unknown postfixeme morpheme: {tok}")                post_list.append(am[tok])    post_obj = Postfixeme(post_list) if post_list else None    form_obj = phonol(buildForm(lex, gr_obj, post_obj) if post_obj else buildForm(lex, gr_obj))    grammeme_ids = [getattr(g, "id", None) or getattr(g, "name", None) for g in getattr(gr_obj, "l", [])]    grammeme_ids = [x for x in grammeme_ids if x]  # фильтруем None/''    cell_json, derivs = form_to_json(        lexeme_id,        grammemes=grammeme_ids,        postfixemes=(post.split("+") if post else []),        form_obj=form_obj,        cell_label=None,    )    for d_ in derivs:        d_["lexeme_id"] = lexeme_id        d_["gr_obj"]    = gr_obj        for s in d_.get("steps", []):            rid = str(s.get("rule_id", "")); obj = rules.get(rid)            s["wording"] = getattr(obj, "wording", "") if obj else ""        _VARIANTS[d_["variant_id"]] = d_    surface = base.get("surface", "")    if cell_json["variants"]:        surface = next((v["surface"] for v in cell_json["variants"] if v["is_canonical"]),                       cell_json["variants"][0]["surface"])    labels = {"": "SIMPLE", "EMPH+NOM": "EMPH+NOM", "1+SG+OBL": "1+SG+OBL", "2+SG+OBL": "2+SG+OBL", "3+SG+OBL": "3+SG+OBL",              "1+PL+OBL": "1+PL+OBL", "2+PL+OBL": "2+PL+OBL", "3+PL+OBL": "3+PL+OBL"}    d = {        "variant_id": variant_id,        "surface": surface,        "steps": [],        "variants": cell_json["variants"],        "allowed_posts": allowed_posts,        "labels": labels,    }    if post == "":        d["initial_variant_id"] = variant_id    else:        canon = [v for v in cell_json["variants"] if v["is_canonical"]]        d["initial_variant_id"] = (canon[0]["variant_id"] if canon else (cell_json["variants"][0]["variant_id"] if cell_json["variants"] else None))    return templates.TemplateResponse(        "partials/postfix_block.html",        {"request": request, "d": d, "show_all": show_all},    )
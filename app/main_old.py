import jsonfrom pathlib import Pathfrom typing import Any, Dict, Listfrom fastapi import FastAPI, Request, Queryfrom fastapi.responses import HTMLResponsefrom fastapi.templating import Jinja2Templatesfrom fastapi import HTTPExceptionfrom fastapi.responses import HTMLResponsefrom .engine.paradigm_builder import (export_paradigm_verb,                                      export_paradigm_nominal, export_paradigm_p3,                                      sublexeme, lx, dictionary_form)from .engine.T1 import rulesimport sys, pathlibsys.path.append(str(pathlib.Path(__file__).resolve().parents[1]))# === настройки путей ===BASE_DIR = Path(__file__).resolve().parent.parentDATA_FILE = BASE_DIR / "data" / "lexemes.json"app = FastAPI()templates = Jinja2Templates(directory=str(Path(__file__).resolve().parent / "templates"))# === кэш лексем в памяти ===_LEXEMES: Dict[str, Dict[str, Any]] = {}_VARIANTS: dict[str, dict] = {}def load_lexemes() -> Dict[str, Dict[str, Any]]:    with open(DATA_FILE, "r", encoding="utf-8") as f:        data = json.load(f)    # нормализуем поля к единым ключам для шаблона    norm: Dict[str, Dict[str, Any]] = {}    for key, row in data.items():        dictform = dictionary_form(lx[key])        norm[key] = {            "name": row.get("name") or key,            "dictform": dictform,            "meaning": row.get("Meaning") or "",            "category": row.get("Category") or "",            "gender": row.get("Gender") or "",        }    return norm@app.on_event("startup")def _startup():    global _LEXEMES    _LEXEMES = load_lexemes()# === главная: таблица лексем ===@app.get("/", response_class=HTMLResponse)def home(request: Request, q: str | None = None):    """    Показываем таблицу лексем. Поддерживаем простой поиск по name/meaning (q).    """    rows: List[Dict[str, Any]] = list(_LEXEMES.values())    # фильтрация по q    if q:        ql = q.lower()        rows = [            r for r in rows            if ql in (r["name"] or "").lower() or ql in (r["meaning"] or "").lower() or  ql in (r["dictform"] or "").lower()        ]    # простая сортировка по name для стабильности    rows.sort(key=lambda r: (r["name"] or "").lower())    return templates.TemplateResponse(        "home.html",        {            "request": request,            "lexemes": rows,            "q": q or "",        },    )@app.get("/lexeme/{lexeme_id}", response_class=HTMLResponse)def lexeme_page(request: Request, lexeme_id: str, sub: str | None = Query(default=None)):    if lexeme_id not in _LEXEMES:        raise HTTPException(status_code=404, detail="Lexeme not found")    base_lex = lx[lexeme_id]    # если передан sub=TAG — строим временную лексему из базовой    cur_lex = sublexeme(base_lex, sub) if sub else base_lex    category = (getattr(cur_lex, "Category", "") or "").lower()    if category == "verb":        payload = export_paradigm_verb(cur_lex)        template_name = "lexeme_verb.html"    elif cur_lex.name == "P_3":        payload = export_paradigm_p3(cur_lex)        template_name = "lexeme_nominal.html"    else:        payload = export_paradigm_nominal(cur_lex)        template_name = "lexeme_nominal.html"    # else:    #     payload = {    #         "version": 1,    #         "lexeme_id": getattr(cur_lex, "name", lexeme_id),    #         "category": category or "unknown",    #         "axes": [], "layout": None, "cells": [],    #         "_derivations": [],    #     }    #     template_name = "lexeme_unsupported.html"    # положим деривации в кэш для кликов по вариантам    for d in payload.get("_derivations", []):        _VARIANTS[d["variant_id"]] = d    # передадим в шаблон базовый id и текущий sub (для навигации/хлебных крошек)    return templates.TemplateResponse(        template_name,        {            "request": request,            "payload": payload,            "lex_row": _LEXEMES[lexeme_id],            "base_id": lexeme_id,            "sub": sub,        },    )@app.get("/api/variant/{variant_id}/derivation", response_class=HTMLResponse)def variant_derivation_partial(request: Request, variant_id: str):    data = _VARIANTS.get(variant_id)    if not data:        raise HTTPException(status_code=404, detail="Variant not found")    # enrich steps with rule wording    steps = data.get("steps", [])    for s in steps:        rid = str(s.get("rule_id", ""))        s["wording"] = getattr(rules.get(rid, None), "wording", "") if rid in rules else ""    return templates.TemplateResponse(        "partials/derivation.html",        {"request": request, "d": data},    )